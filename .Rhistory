typeof(2)
typeof(z)
x3<-c("apple","orange","banana")
x3<-c("apple","orange","banana")
z3<-as.integer(x3)
typeof(z3)
x<- c("let's test this data type. Is it a character?")
is.character(x)
sample(10)+1:9
sample(10)+1:10
tibble(x=1:6,y=rep(1:4,each=2))
1:10+1:2
tibble(x=1:4,y=3:6)
data.frame(x=1:8,y=rep(1:4,2))
data.frame(x=1:3,y=rep(1:3,2))
tibble(x=1:8,y=rep(1:4,each=2))
rep(seq(from=10,to=30,length.out=3),times=3)
rep(c(10,20,30),each=4)
rep(c(10,20,30),times=c(1,2,3))
var1<-c(a=1,b=2,c=3,d=4)
var2<-c(1,2,3,4)
names(var2)<-c("a","b","c")
names(var2)<-c("a","b","c","d")
print(var2)
names(var2)[1:2]
names(var1)[var1==3]
x==3
purr:: set_names(1:4,c("a","b","c","d"))
sim_norm_mean <- function(N, mu=0, sigma=1) {
mean(rnorm(N, mu, sigma))
}
sim_norm_mean(N=100)
# M numbers of sample means
# value list with M rows and NA values
# loop that fills in every value in M with a new mean from 1.1
M <- 20
sample_means <- rep(NA, M)
for( i in 1:M){
sample_means[i] <- round(sim_norm_mean(i), digits=3)
}
sample_means
library(magrittr) # for pipes
library(dplyr) # for datawrangling
# i repeat the proccess from 1.2 and i calculate the tre sigam
n = M
sigma = 1
sd_theoretical = sigma/sqrt(n)
sigma_true
sigma_value =1 #the sigma value for the
# creates columns for the dataframe and two vessels for sd results
number = seq(1, M, by = 1)
sigma = rep(1, M)
sample_sd = rep(NA, M) # sample sd is the theoretical sd
theoretical_sd = rep(NA, M)
NM = seq(10, 200, by =10)
# creates a dataframe
df <- data.frame(number, NM, sigma)
head(df)
df_3 <- df %>%
mutate(
sample_means = sim_norm_mean(N=NM, sigma=sigma),
theroretical_sd = sigma/sqrt(NM),
sample_sd = rep(NA, M)
)
df_3
for( i in 1:M(df_3)){
sample_sd[i] <- sqrt(sim_norm_mean(i)-)
M <- 20
sample_means <- rep(NA, M)
sample_sd <- rep(NA, M)
for( i in 1:M){
N=10
mu=0
sigma=1
sample_means[i] <- round(sim_norm(i), digits=3)
}
# M numbers of sample means
# value list with M rows and NA values
# loop that fills in every value in M with a new mean from 1.1
M <- 20
sample_means <- rep(NA, M)
for( i in 1:M){
sample_means[i] <- round(sim_norm_mean(i), digits=3)
}
sample_means
library(magrittr) # for pipes
library(dplyr) # for datawrangling
# i repeat the proccess from 1.2 and i calculate the tre sigam
n = M
sigma = 1
sd_theoretical = sigma/sqrt(n)
sigma_true
sim_norm_mean <- function(N, mu=0, sigma=1) {
mean(rnorm(N, mu, sigma))
}
sim_norm_mean(N=100)
# M numbers of sample means
# value list with M rows and NA values
# loop that fills in every value in M with a new mean from 1.1
M <- 20
sample_means <- rep(NA, M)
for( i in 1:M){
sample_means[i] <- round(sim_norm_mean(i), digits=3)
}
sample_means
library(magrittr) # for pipes
library(dplyr) # for datawrangling
# i repeat the proccess from 1.2 and i calculate the tre sigam
n = M
sigma = 1
sd_theoretical = sigma/sqrt(n)
sigma_true
sigma_value =1 #the sigma value for the
sigma_value =1 #the sigma value for the
# creates columns for the dataframe and two vessels for sd results
number = seq(1, M, by = 1)
sigma = rep(1, M)
sample_sd = rep(NA, M) # sample sd is the theoretical sd
theoretical_sd = rep(NA, M)
NM = seq(10, 200, by =10)
# creates a dataframe
df <- data.frame(number, NM, sigma)
head(df)
df_3 <- df %>%
mutate(
sample_means = sim_norm_mean(N=NM, sigma=sigma),
theroretical_sd = sigma/sqrt(NM),
sample_sd = rep(NA, M)
)
df_3
simulate_normal_mean <- function(N, mu = 0, sigma = 1) {
# Generate N random observations from a normal distribution
data <- rnorm(N, mean = mu, sd = sigma)
# Calculate the mean of the sample
sample_mean <- mean(data)
}
# Simulate 100 observations from a standard normal distribution (mu = 0, sigma = 1)
result1 <- simulate_normal_mean(N = 100)
# Simulate 250 observations from a normal distribution with mu = 5 and sigma = 2
result2 <- simulate_normal_mean(N = 250, mu = 5, sigma = 2)
# Simulate 1000 observations from a normal distribution with mu = -2 and sigma = 0.5
result3 <- simulate_normal_mean(N = 1000, mu = -2, sigma = 0.5)
M <- 20
sample_means <- rep(NA, M)
for(i in 1:M) {
sample_means[i] <- sim_norm(N = 100, mu = 2, sigma = 0.5)
}
sample_means
### Assignment 4 ###
### BAN400 ###
library(tidyverse)
M <- 20
sample_means <- rep(NA, M)
for(i in 1:M) {
sample_means[i] <- sim_norm(N = 100, mu = 2, sigma = 0.5)
}
?sim_norm
sample_means[i] <- sim_normal(N = 100, mu = 2, sigma = 0.5)
sample_means[i] <- simnorm(N = 100, mu = 2, sigma = 0.5)
sample_means[i] <- simNorm(N = 100, mu = 2, sigma = 0.5)
sample_means
N <- 10
M <- 20
sample_means <- rep(NA, M)
for (i in 1:M) {
sample_means[i] <- sim_norm(N, mu = 0, sigma = 1)
}
M <- 20
sample_means <- rep(NA, M)
for(i in 1:M) {
sample_means[i] <- simulate_normal_mean(N = 100, mu = 2, sigma = 0.5)
}
sample_means
N <- 10
M <- 20
sample_means <- rep(NA, M)
for (i in 1:M) {
sample_means[i] <- sim_norm(N, mu = 0, sigma = 1)
}
sample_means[i] <- simulate_normal_mean(N, mu = 0, sigma = 1)
for (i in 1:M) {
sample_means[i] <- simulate_normal_mean(N, mu = 0, sigma = 1)
}
sample_means
N <- 10
M <- 20
sample_means <- rep(NA, M)
for (i in 1:M) {
sample_means[i] <- simulate_normal_mean(N, mu = 0, sigma = 1)
}
sample_means
# Calculate the standard deviation of the sample means
sample_means_sd <- sd(sample_means)
# Calculate the true standard deviation (sigma / sqrt(N))
true_sd <- 1 / sqrt(N)
# Create a sequence of sample sizes (N)
sample_sizes <- c(10, 20, 30, 40, 50)  # You can adjust this sequence as needed
# Define the common values for sigma and M
sigma <- 1
M <- 1000  # Number of sample means to calculate
# Create a data frame or tibble with the specified columns
results_df <- data.frame(
N = sample_sizes,
st_dev = rep(NA, length(sample_sizes)),
sigma = sigma,
theoretical = sigma / sqrt(sample_sizes)
)
## Task 1.5 ##
# Create a sequence of sample sizes (N)
sample_sizes <- c(10, 20, 30, 40, 50)  # You can adjust this sequence as needed
# Define the common values for sigma and M
sigma <- 1
M <- 1000  # Number of sample means to calculate
# Create a data frame with the specified columns
results_df <- data.frame(
N = sample_sizes,
st_dev = rep(NA, length(sample_sizes)),
sigma = sigma,
theoretical = sigma / sqrt(sample_sizes)
)
# Fill in the st_dev column using a for-loop
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- numeric(M)  # Create an empty vector to store sample means
# Generate M sample means for the current sample size N
for (j in 1:M) {
sample_means[j] <- sim_norm(N, mu = 0, sigma = 1)
}
# Calculate the empirical standard deviation of the sample means and store it in st_dev
results_df$st_dev[i] <- sd(sample_means)
}
## Task 1.6 ##
library(ggplot2)
# Create a ggplot scatterplot comparing observed and theoretical standard deviations
ggplot(results_df, aes(x = N)) +
geom_point(aes(y = st_dev, color = "Observed"), size = 3) +
geom_line(aes(y = theoretical, color = "Theoretical"), linetype = "dashed") +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
ggtitle("Comparison of Observed and Theoretical Standard Deviations") +
theme_minimal()
## Task 1.5 ##
# Create a sequence of sample sizes (N)
sample_sizes <- c(10, 20, 30, 40, 50)  # You can adjust this sequence as needed
# Define the common values for sigma and M
sigma <- 1
M <- 1000  # Number of sample means to calculate
# Create a data frame with the specified columns
results_df <- data.frame(
N = sample_sizes,
st_dev = rep(NA, length(sample_sizes)),
sigma = sigma,
theoretical = sigma / sqrt(sample_sizes)
)
# Fill in the st_dev column using a for-loop
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- numeric(M)  # Create an empty vector to store sample means
# Generate M sample means for the current sample size N
for (j in 1:M) {
sample_means[j] <- simulate_normal_mean(N, mu = 0, sigma = 1)
}
# Calculate the empirical standard deviation of the sample means and store it in st_dev
results_df$st_dev[i] <- sd(sample_means)
}
## Task 1.6 ##
library(ggplot2)
# Create a ggplot scatterplot comparing observed and theoretical standard deviations
ggplot(results_df, aes(x = N)) +
geom_point(aes(y = st_dev, color = "Observed"), size = 3) +
geom_line(aes(y = theoretical, color = "Theoretical"), linetype = "dashed") +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
ggtitle("Comparison of Observed and Theoretical Standard Deviations") +
theme_minimal()
install.packages("tweedie")
library(tweedie)
simTweedieTest <- function(N) {
# Simulate a dataset with a tweedie distribution
simulated_data <- rtweedie(N, mu = 10000, phi = 100, power = 1.9)
# Run a t-test with null hypothesis mu0 = 10000
t_test_result <- t.test(simulated_data, mu = 10000)
# Extract and return the p-value from the t-test result
p_value <- t_test_result$p.value
return(p_value)
}
# Set the number of simulations (M) and the significance level
M <- 1000  # You can adjust this value as needed
alpha <- 0.05
# Initialize a counter for the number of times the null hypothesis is rejected
reject_count <- 0
# Perform the simulation experiment
for (i in 1:M) {
p_value <- simTweedieTest(N = 100)
# Check if the null hypothesis is rejected at the given significance level
if (p_value < alpha) {
reject_count <- reject_count + 1
}
}
# Calculate the rejection rate
rejection_rate <- reject_count / M
MTweedieTests <- function(M, N, alpha) {
# Initialize a counter for the number of times the null hypothesis is rejected
reject_count <- 0
# Perform M simulations
for (i in 1:M) {
p_value <- simTweedieTest(N)
# Check if the null hypothesis is rejected at the given significance level
if (p_value < alpha) {
reject_count <- reject_count + 1
}
}
# Calculate the percentage of tests where the p-value is lower than alpha
rejection_percentage <- reject_count / M
return(rejection_percentage)
}
# Load the necessary packages
library(tibble)
library(ggplot2)
# Create an empty data frame
df <- tibble(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
# Loop through the rows of the data frame and fill in the share_reject column
for (i in 1:nrow(df)) {
N_value <- df$N[i]
M_value <- df$M[i]
alpha <- 0.05  # Set the significance level
# Calculate the share_reject using MTweedieTests function
share_reject <- MTweedieTests(M_value, N_value, alpha)
# Update the data frame with the calculated share_reject value
df$share_reject[i] <- share_reject
}
# Create a figure (plot) with ggplot2
ggplot(df, aes(x = N, y = share_reject)) +
geom_line() +
geom_point() +
labs(x = "Sample Size (N)", y = "Share of Rejections") +
ggtitle("Validity of t-test on Tweedie Distribution") +
theme_minimal()
library(tibble)
library(ggplot2)
library(tweedie)  # Load the tweedie package
# Function to simulate data from Tweedie or Normal distribution
simulate_data <- function(N, distribution = "Tweedie") {
if (distribution == "Tweedie") {
return(rtweedie(N, mu = 10000, phi = 100, power = 1.9))
} else if (distribution == "Normal") {
return(rnorm(N, mean = 10000, sd = 1000))
} else {
stop("Invalid distribution specified.")
}
}
# Function to perform t-test and return p-value
perform_t_test <- function(data, true_mu) {
return(t.test(data, mu = true_mu)$p.value)
}
# Function to simulate M datasets and calculate rejection rate
simulate_and_calculate_rejection_rate <- function(M, N, distribution, alpha) {
reject_count <- 0
for (i in 1:M) {
data <- simulate_data(N, distribution)
p_value <- perform_t_test(data, true_mu = 10000)
if (p_value < alpha) {
reject_count <- reject_count + 1
}
}
return(reject_count / M)
}
# Create a data frame for N values
df <- tibble(N = c(10, 50, 100, 200, 500, 1000, 2000))
# Set the number of simulations and significance level
M <- 1000
alpha <- 0.05
# Create a data frame with rejection rates for both distributions
df <- df %>%
mutate(
tweedie_rejection_rate = simulate_and_calculate_rejection_rate(M, N, "Tweedie", alpha),
normal_rejection_rate = simulate_and_calculate_rejection_rate(M, N, "Normal", alpha)
)
# Create a figure with two curves
ggplot(df, aes(x = N)) +
geom_line(aes(y = tweedie_rejection_rate, color = "Tweedie"), linetype = "solid") +
geom_line(aes(y = normal_rejection_rate, color = "Normal"), linetype = "dashed") +
scale_color_manual(values = c("Tweedie" = "blue", "Normal" = "red")) +
labs(x = "Sample Size (N)", y = "Rejection Rate") +
ggtitle("Validity of t-test on Tweedie vs. Normal Distribution") +
theme_minimal()
# Create a data frame with rejection rates for both distributions
df <- df %>%
mutate(
tweedie_rejection_rate = simulate_and_calculate_rejection_rate(M, N, "Tweedie", alpha),
normal_rejection_rate = simulate_and_calculate_rejection_rate(M, N, "Normal", alpha)
)
library(tidyverse)
raw_data <- readLines(http://www.sao.ru/lv/lvgdb/article/suites_dw_Table1.txt)
raw_data <- readLines("http://www.sao.ru/lv/lvgdb/article/suites_dw_Table1.txt")
raw_data
raw_data(head)
head(raw_data)
head(raw_data,25)
substr(x = raw_file, start = 0, stop = 2)
substr(x = raw_data, start = 0, stop = 2)
L <-
(substr(x = raw_file, start = o, stop = 2) == "--") %>%
function_that_returns_the_index_of_all_TRUES %>%
function_that_picks_out_the_minimum_value
L <-
(substr(x = raw_data, start = o, stop = 2) == "--") %>%
function_that_returns_the_index_of_all_TRUES %>%
function_that_picks_out_the_minimum_value
L<- which(line_start=="--")
line_start=substr(x = raw_data, start = 0, stop = 2)
L<- which(line_start=="--")
L
L<- which(line_start=="--") %>%
min(L)
L
L<- which(line_start=="--") %>%
L_min<-min(L)
L<- which(line_start=="--")
L_min<-min(L)
L_min
L<- which(line_start=="--") %>%
min(L)
L# Save the variable descriptions (i.e. the information in lines 1:(L-2)) in a
cat(1:(L-2), file="variable_descriptions.txt")
cat(1:(L-2), file="variable_descriptions.txt")
pwd
pwd
wd
swd
setwd("C:/Users/rysch/Downloads/git-Annalenary")
cat(1:(L-2), file="variable_descriptions.txt")
cat(L[1:(L-2)], sep="\n",file="variable_descriptions.txt")
cat(print(1:(L-2)), sep="\n",file="variable_descriptions.txt")
cat(paste(1:(L-2)), sep="\n",file="variable_descriptions.txt")
L
cat(raw_data(1:(L-2)), sep="\n",file="variable_descriptions.txt")
cat(raw_data[1:(L-2)], sep="\n",file="variable_descriptions.txt")
cat(raw_data[1:(L-2)], sep="\n",file="variable_descriptions.txt")
var_descriptions
var_descriptions<- cat(raw_data[1:(L-2)], sep="\n",file="variable_descriptions.txt")
var_descriptions
var_descriptions<- cat(raw_data[1:(L-2)], sep="\n",file="variable_descriptions.txt")
var_descriptions<- cat(raw_data[1:(L-2)], sep="\n",file="variable_descriptions.txt")
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
cat(raw_data[(L-1)], sep="\n")
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
var_names<- c(cat(raw_data[(L-1)], sep="\n"))
var_names
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
var_names<- capture.output(cat(raw_data[(L-1)], sep="\n"))
var_names
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
var_names<- capture.output(cat(raw_data[(L-1)]))
var_names
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
var_names2<-raw_data[L-1]
var_names2
# Extract the variable names (i.e. line (L-1)), store the names in a vector.
var_names<-
str_split(string = raw_data[L-1], pattern = "\\|") %>%
unlist() %>%
str_trim()
var_names
comma_separated_values <-
raw_data %>%
gsub("\\|", ",", .) %>%
gsub(" ", "", .)
comma_separated_values
comma_separated_values_with_names <-
c(paste(variable_names, collapse = ","),
comma_separated_values)
comma_separated_values_with_names <-
c(paste(var_names, collapse = ","),
comma_separated_values)
comma_separated_values_with_names
cat(comma_separated_values_with_names, sep = "\n", file = "data_clean.csv")
# Read the finished .csv back into R in the normal way.
read.csv("data_clean.csv")
# Read the finished .csv back into R in the normal way.
data_clean <-read.csv("data_clean.csv")
head(data_clean)
# Read the finished .csv back into R in the normal way.
data_clean <-read.csv("data_clean.csv")
# Read the finished .csv back into R in the normal way.
data_clean <-read.csv("data_clean.csv")
data_clean %>%
group_by(a_26) %>%
ggplot(aes(x=a_26))
data_clean %>%
group_by(a_26) %>%
ggplot(aes(x=a_26))
data_clean %>%
group_by(a_26)
data_clean %>%
group_by(a_26) %>%
head(50)
data_clean %>%
group_by(a_26) %>%
print(n=50)
data_clean %>%
group_by(a_26) %>%
ggplot(aes(x=a_26))+
geom_line(stat="count")
data_clean %>%
group_by(a_26) %>%
ggplot(aes(x="a_26"))+
geom_line(stat="count")
data_clean %>%
group_by("a_26") %>%
ggplot(aes(x="a_26"))+
geom_line(stat="count")
